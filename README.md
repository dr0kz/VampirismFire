VAMPIRISM FIRE 

СЕМИНАРСКА РАБОТА ПО ВИЗУЕЛНО ПРОГРАМИРАЊЕ 

Unity 3D проект 

Слика 1 

Проекот е едноставна имплементација на позната игра од Warcraft 3. 

Link до играта што се имплементира: https://www.youtube.com/watch?v=8bo51iQd_5M 

На Слика 1 ни е претставен интерфејсот кога ја отвараме играта односно во делот на Main Menu. По кликање на Shop не носи до продавница од која може да отклучуваме нови објекти или да вршиме надградба на веќе постоечки. По кликање на Play играта почнува. На Слика 2 и Слика 3 ни е прикажан дел од продавницата. Лево горе сликата ни кажува за кој објект се однесуваат ставките.  


Целта на играта е да ја одбраните вашата територија , поточно еден објект кој се наоѓа во вашата територија од непријателите низ повеќе непријателски бранови.  

Победувате кога ќе ги исчистите сите бранови на непријатели, а губите кога непријателите ќе ви го уништат објектот.  

Секој бран е потежок и поразличен од претходниот. Во вашата територија имате поставено мали интерактивни површини. Овие површини при клик ви даваат избор на објекти кои можете да ги поставите. Секој објект си има своја функција. Од голема важност е изборот на објектот во секој момент од играта како и брзината со која напредувате. Ги имаме на располагање следниве објекти: 

Објекти за фармање се Lumber Mill и Gold Mine 

Објекти за одбрана се Small Wall, Big Wall и Heal Tower која ги лечи работниците 

Објекти за напад се Damage Tower кои прават штета врз непријателите 

Објект со Spells (Arcane) 

 

Text BoxText BoxНа Слика 4 и Слика 5 ни е прикажан интерфејсот при кликање на некое од белите површини и LumberMill објект соодветно. Се појавува позадина за копчињата и X број на копчиња. Копчињата може да се најдат во различна состојба во зависност од: 

 

Достапноста на ресурси како дрво и злато 

Дали е отклучен објектот од продавницата 

Дали е веќе искористено копчето 

Дали има доволно храна 

 

Работникот и непријателот се AI агенти. Дополнително овозможено ни е лимитирано контролирање на работникот. Можеме да го селектираме и да му дадеме крајна дестинација која мора да биде градба. Доколку дестинацијата не е Lumber Mill почнува со поправање на истата без разлика дали и фали живот (health) , а доколку е Lumber Mill повторно почнува да собира дрва и да носи во Lumber Mill-от каде што на корисникот му се покачува вредноста на ресурсот. 

 

 

 

 

Се користат од едноставни до сложени податочни структури. 

 

Во делот за Shop искористени се неколку класи.  

Имаме класа Shop која има List<Page>. Во оваа листа се чуваат различни страници. Секоја од овие страници Pages има List<Item>. Item e една ставка од страница. Од Item се наследени две класи. ItemUpgradeable и ItemUnlocker во која е искористен Composite Design Pattern односно во неа се чува List<Item> која може да се изминува рекурзивно целата или пак да се манипулира на начин кој ние сакаме.  

 

Копчињата кои се однесуваат за интерактивните објекти се чуваат во низа MyButton[]. Објектите кои се линкнуваат со овие копчиња се чуваат во низа MonoBehaviour[]. За интерактивните објекти избрана е таа класа бидејќи од неа наследуваат сите објекти кои може да се инстанцираат.  

Дополнително се чува Dictionary<MyButton, MonoBehavior> и се линкнува секое копче со соодветниот објект бидејќи многу голем дел од времето се употребуваат овие копчиња па важна ни е комплексноста.  

 

WorkerManager ни е Singleton. Искористена е следнава податочна структура внатре во оваа класа.  

Dictionary<Worker, Dictionary<Renderer, List<Color>>> workerColorsDictionary;  

Се користи во функција за промена на боја на работниците кога е селектирана HealTower. Секој Worker објект има повеќе Renderer компоненти, секоја Renderer компонента има низа од Materials, а секој Material има боја па ова овозможува да ја менуваме и враќаме старата боја на работниците во зависност дали е селектирана или не HealTower. Комплексноста на функцијата која го овозможува ова е во најлош случај е O(n^3) и не е возможна оптимизација преку код. 

 

Во класата BuildingManager која е исто Singleton се чува  

Dictionary<float, List<Wall>> wallsDictionary. Во играта имаме функционалност која не така се гледа на прв поглед. Можно е да споиме три објектите од тип Wall и да станат еден објект од тип BigWall кој наследува од Wall и дополнително чува List<PlaneBuilder> бидејќи е поголем и лежи на поголем број рамнини.   

Алгоритмот работи на следниот начин. 

 

private void AddWallToDictionary(Wall wall) 
    { 

        if (!wallsDictionary.ContainsKey(wall.transform.position.x)) 					
        wallsDictionary.Add(wall.transform.position.x, new List<Wall>()); 

        if (!wallsDictionary.ContainsKey(wall.transform.position.z)) 					
        wallsDictionary.Add(wall.transform.position.z, new List<Wall>()); 

        List<Wall> list1 = new List<Wall>(); 

        wallsDictionary.TryGetValue(wall.transform.position.x, out list1); 

        list1.Add(wall); 

        List<Wall> list2 = new List<Wall>(); 

        wallsDictionary.TryGetValue(wall.transform.position.z, out list2); 

        list2.Add(wall); 

        if (!MergeWalls(list1, true)) MergeWalls(list2, false); 
    } 

private bool MergeWalls(List<Wall> walls, bool rotateWall) // O(n + nlog(n)) 
    { 
        walls.Sort((k, v) => CompareWalls(k, v)); 

        for (int i = 1; i < walls.Count - 1; i++) 

        { 

            if (CheckIfMergingPossible(walls[i - 1], walls[i], walls[i + 1])) 

            { 

                BigWall wall = Instantiate(bigWall); 

                if (rotateWall) wall.transform.Rotate(0, 90, 0, Space.World); 

                wall.SetStandingPlane(walls[i].GetStandingPlane()); 

                List<PlaneBuilder> standingPlanes = new List<PlaneBuilder>(); 

                standingPlanes.Add(walls[i - 1].GetStandingPlane()); 

                standingPlanes.Add(walls[i + 1].GetStandingPlane()); 

                wall.SetStandingPlanes(standingPlanes); 

                walls[i + 1].DestroyBuilding(null); 

                walls[i].DestroyBuilding(null); 

                walls[i - 1].DestroyBuilding(null); 

                return true; 
            } 
        } 
        return false; 
    } 

private int CompareWalls(Wall x, Wall y) 

    { 
        return x.transform.position.x.CompareTo(y.transform.position.x) == 0 ? 
        x.transform.position.z.CompareTo(y.transform.position.z) : 		 	       	
        x.transform.position.x.CompareTo(y.transform.position.x); 
    } 

private bool CheckIfMergingPossible(Wall x, Wall y, Wall z) 
    {
       return (!(x is BigWall) && !(y is BigWall) && !(z is BigWall) && 

           Mathf.Abs(Vector3.Distance(y.transform.position, x.transform.position)) < 3.3f 

           && Mathf.Abs(Vector3.Distance(y.transform.position, z.transform.position)) < 3.3f); 
    } 

Кога поставуваме градба во сцената проверуваме дали е од тип Wall. Доколку е така ја повикуваме функцијата private void AddWallToDictionary(Wall wall). 

 
Ако речникот ги содржи x и z координатите на објектот тогаш го додаваме во двете листи во спротивно прво ги иницијализираме листите па потоа го додаваме. Потоа се повикува private bool MergeWalls(List<Wall> walls, bool rotateWall) // O(n + nlog(n)) 

со првата листа односно со сите објекти кои имаат иста x координата. Оваа листа се сортира со помош на функцијата private int CompareWalls(Wall x, Wall y). 

Доколку не помине тестот со првата листа потоа се прави истото и со втората. 

 
Откако листата е сортирана, со едно изминување од вториот до предпоследниот објект проверуваме дали спојувањето е можно на три објекти од тип Wall со функцијата  

private bool CheckIfMergingPossible(Wall x, Wall y, Wall z). 

Во функцијата мораме прво да провериме дали објектот е строго од тип Wall а не од некоја изведена класа и мораме да го провериме растојанието помеѓу соседите ( земено е да е помало од 3.3f ). 

Штом овој тест ќе помине се инстанцира објект од тип BigWall и дополнително во неговата List<PlaneBuilder> се додаваат крајните две површини а средната се става во променливата standingPlane. Претходните објекти се уништуваат! 

 

Ќе ја опишеме класата Worker која се однесува на работникот. 


Напомена: Не е користено property за ниедна од променливите. Не е возможно од самиот софтвер да направиме [SerializeField] и Property, а сепак да ни ја покаже променливата во инспекторот. Искористена е максимална енкапсулација и пристапот до променливите однадвор е менаџиран со Getters и Setters! 
 

Се користи A* за движење и наоѓање најкраток пат. 

 
Оваа класа наследува од Character и дополнително ги има интерфејсите ISelectable, IWorkerUpdatable, ICost. 

ISelectable и имплементацијата на функциите го прави објектот интерактивен со корисникт. 

IWorkerUpdatable ни е интерфејс за имплементација на Observer Design Pattern кој е интегриран заедно со WorkerManager Singleton, и има обременета update() функција од првиот интерфејс од кој наследува. 

ICost враќа цена на објектот и информација за дали е отклучен од продавницата. (Овој интерфејс се користи при кликање на интерактивен објект и сетирање на состојбата (state) на копчињата). 

IInstantiatable ни е интерфејс со еден метод void Init(IInstantiatable prefab) кој се користи за иницијализација на објектот. 

IDamageable форсира имплементација на void TakeDamage(float damageAmount) која кажува дека објектот може да се повреди и да биде уништен. 

 

Имплементиран е State Design Pattern. Овој AI има 6 states во кој може да се најде (Дефинирани се како readonly во регионот Worker States). 


При инстанцирање на работник тој се наоѓа во runningTowardState. Самото име кажува дека се движи кон нешто, а тоа е closestTree кое го наоѓа од функција која се наоѓа во LumberMill класата, a LumberMill објектот од каде потекнува првично е доделена во Init(IInstantiatable _building) функцијата. 
 

Потоа choppingTreeState означува дека се наоѓа во фаза на собирање дрва. 


RepairState имаме кога поправа објект. 

 

IdleState е специфичен. Во оваа состојба се наоѓа кога претходно се движел кон некој објект и тој објект е уништен пред да дојде до него. Работникот влегува во состојба idleState и во зависност од тоа дали носи дрва или не ќе се пушти соодветна анимација. 

 

BringingWoodState имаме кога завршил со собирање дрва и носи кон неговиот LumberMill објект.  

 

И накрај имаме leaveWoodState во која се проверува дали работникот ги доставил дрвата до неговиот LumberMill објект (ако допре друг објект од ист тип нема да ги прифати дрвата). 

 

Во WorkerManager го регистрираме работникот за подоцна ако е потребно да се прави notify на истиот. BuildingManager ни е исто Singleton во кој чуваме List<Building> и некои други променливи и податочни структури. При селекција на работник се користи функцијата BUILDINGS_MANAGER.ChangeBuildingsColor(true); 

Прима bool параметар кој кажува дали е објектот селектиран. Во овој случај ја менува бојата на сите градби се со цел да му се каже на корисникот дека работник е селектиран и дека може да го насочи до некоја од нив. 

 

1.Што ако инстанцираме LumberMill објект за работникот и после некое време инстанцираме друг поблиску до него? 

 

2.Што ако надградиме градба додека работник ја поправа истата или се движи кон неа? Се инстанцира нов објект а стариот се брише.... па како ќе знае работникот да продолжи да се движи кон новиот или да го поправа новиот ако претходно тоа го правел? 

 

3.Што ако уништиме градба кон која оди работник а сеуште не е пристигнал? 

 

Искористен е Observer Design Pattern заедно со WorkerManager Singleton. 

 

1.Доколку се постави нов LumberMill се прави update() (notify) на сите објекти од класата Worker и оваа функција ја повикува следнава која има толерантна комплексност. 

 

public void FindClosestFarm() //O(n) 

{ 

//Со transform.position се зeма Vector3(x,y,z) позицијата во 3Д координатниот систем на објект 

//Со .GetComponent<Class>() се зима компонентата Class доколку ја поседува објектот 

    farm = BUILDINGS_MANAGER 

        .getBuildings() 

        .Where(building => building.GetComponent<LumberMill>() != null) 

        .OrderBy((building) => Vector3.Distance(transform.position,building.transform.position) 

        .FirstOrDefault() as LumberMill; 

} 

Од овде е јасно дека следната најблиска фарма за работникот е променета.  

Истото сценарио го имаме и кога се уништува објект од тип LumberMill. 

2. 

public void update(Building building, Building nextBuilding) 

{ 

    if (destination == building.gameObject) destination = nextBuilding.gameObject; 

} 

Едноставно ако дестинацијата е објектот кој што се надградува тогаш дестинацијата се поставува на тој објект и работникот продолжува да оди кон него или поправува. 

3. 

public void update(Building building) 

{ 

    if (destination == building.gameObject) SetState(idleState); 

    if (building.GetComponent<LumberMill>() != null) update(); 

} 

Доколку е објект кон кој се движи работникот тогаш се менува состојбата во idleState. 

Втората линија служи доколку работникот е во choppingTreeState а ние го уништиме неговиот најблизок LumberMill објект. Тогаш повторно се повикува update() методот за да се најде најблискиот (доколку постои).Доколку инстанцираме работници и го уништиме LumberMill објектот тогаш тие бесконечно долго ќе работат притоа не надминувајќи го лимитот кој го имаат на располагање и кој се наоѓа во SavedData. Дури кога ќе поставиме таков објект ќе се повика update() методот. 

 
Како се игра?
Најгоре на екранот ви се прикажани ресурсите кои ви се на располагање (храна , дрва ,
злато). Десно горе се наоѓа копче за пауза. Кога ќе го кликнете, играта се паузира и ви
се отвара модален прозорец. Од овде можете да ја изгасите музиката или звучните
ефекти, да го рестартирате левелот или да одите назад во главното мени.
Се игра само со гушецот без никаква потреба од тастатура. Во зависност од која страна
на екранот сте ја допреле со стрелката, во таа насока се движите во самата сцена.
Со левиот клик селектирате работи во сцената додека со кругчето се движите по
вертикала.
Почнете со LumberMill и брзо инстанцирајте работници од LumberMill-от кој сте го
поставиле и кои веднаш почнуваат со собирање на ресурс дрво. Потоа искористете ги
трите интерактивни површини кои се на влезот во вашата територија и поставете три
објекти од тип Wall. По поставување на третиот објект од тип Wall , тие ќе се спојат во
еден објект од тип BigWall и потоа можете да продолжите со надградување на тој објект.
Почнете да поставувате и Towers. Со тоа ќе инстанцирате кула која нема никаква улога.
Со повторно кликнување на кулата која сте ја инстанцирале ќе можете да одберете
Damage Tower. Со овој објект ги убивате непријателите. Пред да дојдат непријателите
можете со клик на работник да го насочите кон ѕидот кој сте го поставиле претходно или
некој друг објект. Со тоа работникот ќе почне да го поправа. Можете да направите
повеќе работници да поправаат а не само еден, но внимавајте бидејќи со премалку
работници кои собираат ресурси нема да можете да напредувате толку брзо! Поставете
и неколку објекти од тип Gold Mine. Со тоа ќе ви се покачува ресурсот злато и ќе можете
подоцна да поставиме објект од тип Arcane кој е неопходен во подоцнежната фаза од
играта, се разбира мора да ви е отклучен од Shop-от.
Од Shop-от можете да отклучувате нови објекти од тип Wall и DamageTower како и нивно
надградување на health и damage соодветно. Отклучување на Arcane ќе ви овозможи
негова достапност во играта. Овој објект има три магии кои може да се искористат само
еднаш во текот на еден левел. Имате магија за двојно зголемување на armor на објекти
од тип Wall, двојно зголемување на damage на објекти од тип DamageTower и backdoor
protection која ви ги штити сите моментално поставени објекти извесен временски
период.
Внимавајте!
 Колку подолго време го оставите непријателот да удира некој објект, толко посилен
станува ( со секој удар добива дополнителен damage и брзината со која удира )
 Доколку се одлучите да не поставите објекти од тип Wall на влезот на територијата ,
односно поставите на пример во линија со објектот кој е во вашата територија, тогаш тој
објект може да ги изфилтрира дел од непријателите ( непријател кога ќе допре некој
објект почнува да удира на него ), но постојат и паметни непријатели ( AI агенти ) кои
прават bypass на сите објекти ако и само ако имаат пат до дестинацијата ( вашиот главен
објект во територијата )
На располагање ви се многу ресурси ( diamonds ) во Shop-от. Пробајте ги сите објекти и
надградувања.
Целта е да се испробаат функционалностите и алгоритмите на играта, да се видат
податочните структури во акција и да се видат визуелните ефекти, левел дизајнот,
целиот frontend.
Сите класи, интерфејси, функции, се експлицитно напишани од мене.
Целиот frontend (2Д sprites, 3D models) е направен од мене освен particle effects кои се
превземени од Asset Store како и звуците кои се превземени од youtube.
Не е направен баланс во играта, не е извршено доволно тестирање и
оптимизирање. Оставен е само еден левел за тестирање со десет бранови.
Можно е појавување на bugs како и crash на играта.

